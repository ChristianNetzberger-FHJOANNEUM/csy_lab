-- VHDL Entity csy_lib.top_csy_core.symbol
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 19:19:06 24.10.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

entity top_csy_core is
   generic( 
      C_CORE_CLK_FREQUENCY : integer          := 108000000;
      C_NUM_INTR           : integer          := 2;
      C_NUM_GPO            : integer          := 2;
      C_SLV_ADDR_BASE      : std_logic_vector := X"0000";
      C_SLV_ADDR_RANGE     : std_logic_vector := X"0010";
      C_SYNTHESIS_OPTION   : integer          := 1 ;
      simulation_g         : boolean          := false
   );
   port( 
      buttons        : in     std_logic_vector (3 downto 0);
      clk            : in     std_logic;
      recdat         : in     std_logic;
      reset          : in     std_logic;
      sbus_ack_mst   : in     std_logic;
      sbus_addr      : in     std_logic_vector (15 downto 0);
      sbus_be        : in     std_logic_vector (3 downto 0);
      sbus_rd        : in     std_logic;
      sbus_rdata_mst : in     std_logic_vector (31 downto 0);
      sbus_wdata     : in     std_logic_vector (31 downto 0);
      sbus_we        : in     std_logic;
      serial_rxd     : in     std_logic;
      sliders        : in     std_logic_vector (3 downto 0);
      bclk           : out    std_logic;
      gpo            : out    std_logic_vector (C_NUM_GPO-1 downto 0);
      irq_o          : out    std_logic_vector (C_NUM_INTR-1 downto 0);
      leds           : out    std_logic_vector (3 downto 0);
      mclk           : out    std_logic;
      mute           : out    std_logic;
      pbdat          : out    std_logic;
      pblrc          : out    std_logic;
      reclrc         : out    std_logic;
      sbus_ack       : out    std_logic;
      sbus_addr_mst  : out    std_logic_vector (15 downto 0);
      sbus_be_mst    : out    std_logic_vector (3 downto 0);
      sbus_rd_mst    : out    std_logic;
      sbus_rdata     : out    std_logic_vector (31 downto 0);
      sbus_wdata_mst : out    std_logic_vector (31 downto 0);
      sbus_we_mst    : out    std_logic;
      scl            : out    std_logic;
      serial_en      : out    std_logic;
      serial_txd     : out    std_logic;
      sda            : inout  std_logic
   );

-- Declarations

end top_csy_core ;

--
-- VHDL Architecture csy_lib.top_csy_core.struct
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 19:19:06 24.10.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
library work;
use work.busdef.all;

library csy_lib;

architecture struct of top_csy_core is

   -- Architecture declarations

   -- Internal signal declarations
   signal audio_codec_i        : std_logic_vector(31 downto 0);
   signal audio_codec_o        : std_logic_vector(31 downto 0);
   signal audio_in_left        : std_logic_vector(23 downto 0);
   signal audio_in_right       : std_logic_vector(23 downto 0);
   signal audio_out_left       : std_logic_vector(23 downto 0);
   signal audio_out_right      : std_logic_vector(23 downto 0);
   signal audio_sample_en      : std_logic;
   signal audio_testmodes      : std_logic_vector(3 downto 0);
   signal audioloop            : std_logic;
   signal buttons_s            : std_logic_vector(3 downto 0);
   signal buttons_stb          : std_logic_vector(3 downto 0);
   signal ctrlmode             : std_logic;
   signal dds_strobe           : std_logic;
   signal dds_wave1            : std_logic;
   signal dds_wave2            : std_logic;
   signal fcw_lfsr             : std_logic_vector(31 downto 0);
   signal fcw_pulsetrain       : std_logic_vector(31 downto 0);
   signal hi                   : std_logic;
   signal hi4                  : std_logic_vector(3 downto 0);
   signal irq0_clear           : std_logic;
   signal irq0_flag            : std_logic;
   signal irq0_mask            : std_logic;
   signal irq0_trig            : std_logic;
   signal irq1_clear           : std_logic;
   signal irq1_flag            : std_logic;
   signal irq1_mask            : std_logic;
   signal irq1_trig            : std_logic;
   signal lfsr_dout            : std_logic;
   signal lo                   : std_logic;
   signal lo2                  : std_logic_vector(1 downto 0);
   signal lo4                  : std_logic_vector(3 downto 0);
   signal pulse                : std_logic;
   signal pulse_length         : std_logic_vector(31 downto 0);
   signal pulse_trigger        : std_logic;
   signal reg00                : std_logic_vector(31 downto 0);
   signal reg00_in             : std_logic_vector(31 downto 0);
   signal reg01                : std_logic_vector(31 downto 0);
   signal reg01_def            : std_logic_vector(31 downto 0);
   signal reg01_in             : std_logic_vector(31 downto 0);
   signal reg02                : std_logic_vector(31 downto 0);
   signal reg02_def            : std_logic_vector(31 downto 0);
   signal reg02_in             : std_logic_vector(31 downto 0);
   signal reg03                : std_logic_vector(31 downto 0);
   signal reg03_def            : std_logic_vector(31 downto 0);
   signal reg03_in             : std_logic_vector(31 downto 0);
   signal reg04                : std_logic_vector(31 downto 0);
   signal reg04_def            : std_logic_vector(31 downto 0);
   signal reg04_in             : std_logic_vector(31 downto 0);
   signal reg05                : std_logic_vector(31 downto 0);
   signal reg05_in             : std_logic_vector(31 downto 0);
   signal reg06                : std_logic_vector(31 downto 0);
   signal reg06_in             : std_logic_vector(31 downto 0);
   signal reg07                : std_logic_vector(31 downto 0);
   signal reg07_in             : std_logic_vector(31 downto 0);
   signal reg08                : std_logic_vector(31 downto 0);
   signal reg08_in             : std_logic_vector(31 downto 0);
   signal reg09                : std_logic_vector(31 downto 0);
   signal reg09_in             : std_logic_vector(31 downto 0);
   signal reg0A                : std_logic_vector(31 downto 0);
   signal reg0A_in             : std_logic_vector(31 downto 0);
   signal reg0B                : std_logic_vector(31 downto 0);
   signal reg0B_in             : std_logic_vector(31 downto 0);
   signal reg0C                : std_logic_vector(31 downto 0);
   signal reg0C_in             : std_logic_vector(31 downto 0);
   signal reg0D                : std_logic_vector(31 downto 0);
   signal reg0D_in             : std_logic_vector(31 downto 0);
   signal reg0E                : std_logic_vector(31 downto 0);
   signal reg0E_in             : std_logic_vector(31 downto 0);
   signal reg0F                : std_logic_vector(31 downto 0);
   signal reg0F_in             : std_logic_vector(31 downto 0);
   signal reg_din              : std_logic_vector( 16*32-1 downto 0 );    -- parallel input for readback
   signal reg_dout             : std_logic_vector( 16*32-1 downto 0 );    -- parallel output of all registers
   signal reg_rd               : std_logic_vector( 15 downto 0);
   signal reg_update           : std_logic;
   signal reg_we               : std_logic_vector( 15 downto 0);          -- active high write strobes
   signal resetval             : std_logic_vector( 16*32-1 downto 0 );
   signal sbus_i               : sbus_i_t;
   signal sbus_o               : sbus_o_t;
   signal sda_i                : std_logic;
   signal sda_o                : std_logic;
   signal sda_t                : std_logic;
   signal serial_rxd_resampled : std_logic;
   signal serial_trigger       : std_logic;
   signal serial_wav           : std_logic;
   signal sliders_s            : std_logic_vector(3 downto 0);
   signal sliders_stb          : std_logic_vector(3 downto 0);
   signal txmode               : std_logic;
   signal wave_select          : std_logic;
   signal wavsel               : std_logic_vector(3 downto 0);


   -- Component Declarations
   component codec_interface
   generic (
      core_clk_freq_g : integer := 125000000
   );
   port (
      audio_out_left  : in     std_logic_vector (23 downto 0);
      audio_out_right : in     std_logic_vector (23 downto 0);
      clk             : in     std_logic ;
      line_select     : in     std_logic ;
      mic_select      : in     std_logic ;
      recdat          : in     std_logic ;
      reset           : in     std_logic ;
      sda_i           : in     std_logic ;
      testmodes       : in     std_logic_vector (3 downto 0);
      audio_in_left   : out    std_logic_vector (23 downto 0);
      audio_in_right  : out    std_logic_vector (23 downto 0);
      bclk            : out    std_logic ;
      mclk            : out    std_logic ;
      mute            : out    std_logic ;
      pbdat           : out    std_logic ;
      pblrc           : out    std_logic ;
      reclrc          : out    std_logic ;
      sample_en_o     : out    std_logic ;
      scl             : out    std_logic ;
      sda_o           : out    std_logic ;
      sda_t           : out    std_logic 
   );
   end component;
   component comp_dds
   generic (
      nbits_g : integer := 32
   );
   port (
      fcw        : in     std_logic_vector (nbits_g-1 downto 0);
      reset      : in     std_logic ;
      enable     : in     std_logic ;
      clk        : in     std_logic ;
      dds_strobe : out    std_logic ;
      dds_wave   : out    std_logic 
   );
   end component;
   component comp_delay_bit
   generic (
      delay_g : integer := 1
   );
   port (
      din   : in     std_logic ;
      reset : in     std_logic ;
      clk   : in     std_logic ;
      din_q : out    std_logic 
   );
   end component;
   component comp_oneshot
   generic (
      nbits_g : integer := 16
   );
   port (
      pulse_length : in     std_logic_vector (nbits_g-1 downto 0);
      trigger      : in     std_logic ;
      enable       : in     std_logic ;
      reset        : in     std_logic ;
      clk          : in     std_logic ;
      pulse        : out    std_logic 
   );
   end component;
   component comp_signal_synchr
   generic (
      simulation_g : boolean := false
   );
   port (
      buttons      : in     std_logic_vector (3 downto 0);
      sliders      : in     std_logic_vector (3 downto 0);
      encoder0     : in     std_logic_vector (1 downto 0);
      encoder1     : in     std_logic_vector (1 downto 0);
      buttons_s    : out    std_logic_vector (3 downto 0);
      sliders_s    : out    std_logic_vector (3 downto 0);
      encoder0_s   : out    std_logic_vector (1 downto 0);
      encoder1_s   : out    std_logic_vector (1 downto 0);
      buttons_stb  : out    std_logic_vector (3 downto 0);
      sliders_stb  : out    std_logic_vector (3 downto 0);
      encoder0_stb : out    std_logic_vector (1 downto 0);
      encoder1_stb : out    std_logic_vector (1 downto 0);
      clk          : in     std_logic 
   );
   end component;
   component lfsr
   generic (
      seed_g : integer := 1
   );
   port (
      clk       : in     std_logic;
      en        : in     std_logic;
      lfsr_din  : in     std_logic;
      reset     : in     std_logic;
      lfsr_dout : out    std_logic
   );
   end component;
   component register_array_resetval
   generic (
      addr_width_g : integer := 8;      --width of address
      data_width_g : integer := 8;      --width of data
      addr_base_g  : std_logic_vector;
      addr_range_g : std_logic_vector;
      nregs_g      : integer := 16      --number of registers
   );
   port (
      sbus_o   : out    sbus_o_t ;
      sbus_i   : in     sbus_i_t ;
      resetval : in     std_logic_vector ( nregs_g*data_width_g-1 downto 0 );
      reg_din  : in     std_logic_vector ( nregs_g*data_width_g-1 downto 0 ); -- parallel input for readback
      reg_dout : out    std_logic_vector ( nregs_g*data_width_g-1 downto 0 ); -- parallel output of all registers
      we       : out    std_logic_vector ( nregs_g-1 downto 0);               -- active high write strobes
      rd       : out    std_logic_vector ( nregs_g-1 downto 0);               -- active high write strobes
      reset    : in     std_logic ;                                           -- synchronous, active high reset
      clk      : in     std_logic ;                                           -- register clock
      update   : out    std_logic 
   );
   end component;

   -- Optional embedded configurations
   -- pragma synthesis_off
   for all : codec_interface use entity csy_lib.codec_interface;
   for all : comp_dds use entity csy_lib.comp_dds;
   for all : comp_delay_bit use entity csy_lib.comp_delay_bit;
   for all : comp_oneshot use entity csy_lib.comp_oneshot;
   for all : comp_signal_synchr use entity csy_lib.comp_signal_synchr;
   for all : lfsr use entity csy_lib.lfsr;
   for all : register_array_resetval use entity csy_lib.register_array_resetval;
   -- pragma synthesis_on


begin
   -- Architecture concurrent statements
   -- HDL Embedded Text Block 1 eb1
   process(clk)
   begin
      if rising_edge(clk) then
            if txmode = '0' then
               serial_en <= sliders_s(0) ;
            else 
                serial_en <= not serial_wav;
            end if;
            serial_txd <= serial_wav;  
     end if;
   end process;
   
   
   
   

   -- HDL Embedded Text Block 2 eb2
   -- eb2 2   
   gpo(0) <= serial_trigger;
   gpo(1) <= serial_rxd_resampled;    
   leds(0) <= sliders_s(0);                                

   -- HDL Embedded Text Block 3 reg_defaults1
   -- reg_defaults 
   reg01_def <= X"00000000"; -- max value for 1k FIFO
   reg04_def <= X"00001000"; -- max value for 1k FIFO
   reg03_def <= X"0000C000"; -- max value for 1k FIFO
   reg02_def <= X"00400000"; -- max value for 1k FIFO
   
                                                     
   
   
   
   
   
   
   
   
   
   
   
   
   

   -- HDL Embedded Text Block 4 mux
   process(clk)
   begin
      if rising_edge(clk) then
         if  wave_select = '0'  then
             serial_wav <= lfsr_dout;
             serial_trigger <= dds_wave1;
         else
             serial_wav <= pulse;
             serial_trigger <= not dds_wave2;
         end if;
      end if;
   end process;  
   
   wave_select <= wavsel(0) when ctrlmode = '1' else sliders_s(1);
                               

   -- HDL Embedded Text Block 5 eb3
   wavsel <= reg01(3 downto 0);
   txmode <= reg01(8);
   ctrlmode <= reg01(12);
   fcw_lfsr <= reg02; 
   fcw_pulsetrain <= reg03;
   pulse_length <= reg04;
   audio_testmodes <= reg06(3 downto 0);
   audioloop <= reg06(4);                             

   -- HDL Embedded Text Block 7 reg_slice5
   --slice registers from vector---------------
   reg00 <= reg_dout( 0*32+31 downto 0*32);
   reg01 <= reg_dout( 1*32+31 downto 1*32);
   reg02 <= reg_dout( 2*32+31 downto 2*32);
   reg03 <= reg_dout( 3*32+31 downto 3*32);
   reg04 <= reg_dout( 4*32+31 downto 4*32);
   reg05 <= reg_dout( 5*32+31 downto 5*32);
   reg06 <= reg_dout( 6*32+31 downto 6*32);
   reg07 <= reg_dout( 7*32+31 downto 7*32);
   reg08 <= reg_dout( 8*32+31 downto 8*32);
   reg09 <= reg_dout( 9*32+31 downto 9*32);
   reg0A <= reg_dout( 10*32+31 downto 10*32);
   reg0B <= reg_dout( 11*32+31 downto 11*32);
   reg0C <= reg_dout( 12*32+31 downto 12*32);
   reg0D <= reg_dout( 13*32+31 downto 13*32);
   reg0E <= reg_dout( 14*32+31 downto 14*32);
   reg0F <= reg_dout( 15*32+31 downto 15*32);
   
   ---readback register values----
   process(clk)
   begin
      if rising_edge(clk) then
            -- default assignment: internal register readback----------
            reg_din <= reg_dout; 
            --external readback registers-----
          --uncomment line if external readback wanted
   --         reg_din(0*32+31 downto 0*32) <= reg00_in;
              reg_din(2*32+31 downto 2*32) <= reg02_in;
   --         reg_din(3*32+31 downto 3*32) <= reg03_in;
   --         reg_din(4*32+31 downto 4*32) <= reg04_in;
   --         reg_din(7*32+31 downto 7*32) <= reg07_in;
   --         reg_din(13*32+31 downto 13*32) <= reg0D_in;
   --         reg_din(7*32+31 downto 7*32) <= reg07_in;
       end if;
   end process;
                                                                  
   
   
   
   
   

   -- HDL Embedded Text Block 9 const_values4
   hi <= '1';
   lo <= '0';   
   lo2 <= (others => '0');     
   lo4 <= (others => '0');     
   hi4 <= (others => '1');                                 

   -- HDL Embedded Text Block 11 slave_bus_attachment3
   ----create record-types for sbus--------------------
   sbus_i.addr <= sbus_addr;
   sbus_i.wdata <= sbus_wdata;
   sbus_i.be <= sbus_be;
   sbus_i.we <= sbus_we;
   sbus_i.rd <= sbus_rd;
   ---multiplexing two sbus branches-----
   sbus_ack <= sbus_o.ack or sbus_ack_mst;
   sbus_rdata <= sbus_o.rdata or sbus_rdata_mst;
   
   sbus_addr_mst <= sbus_addr;
   sbus_wdata_mst <= sbus_wdata;
   sbus_be_mst <= sbus_be;
   sbus_we_mst <= sbus_we;
   sbus_rd_mst <= sbus_rd;
   

   -- HDL Embedded Text Block 12 reg_resetvalues3
   --default reset values for registerblock
   process(resetval,reg01_def)
   begin
      resetval <= (others => '0');
      resetval(1*32+31 downto 1*32) <= reg01_def;
      resetval(2*32+31 downto 2*32) <= reg02_def;
      resetval(3*32+31 downto 3*32) <= reg03_def;
      resetval(4*32+31 downto 4*32) <= reg04_def;
   end process;                                
   
   
   
   
   
   
   
   
   
   
   
   

   -- HDL Embedded Text Block 13 tristate_pin3
   --bidirectional port sda
   sda_i <= sda;
   --tristate enable is active low
   sda <= sda_o when sda_t = '0' else 'Z';                                    

   -- HDL Embedded Text Block 14 codec_sig1
   -- eb8 13  
        audio_codec_i(31 downto 16) <= audio_in_right(23 downto 8);
        audio_codec_i(15 downto 0)  <= audio_in_left(23 downto 8);
   
   process(audio_in_right, audio_in_left,audio_codec_o,audioloop)
   begin
     if audioloop = '0' then
        audio_out_right <= audio_codec_o(31 downto 16) & X"00";   
        audio_out_left <= audio_codec_o(15 downto 0) & X"00";   
      else
        audio_out_right <= audio_in_right;   
        audio_out_left <= audio_in_left;   
      end if;
   end process;                                    
   

   -- HDL Embedded Text Block 16 rd_regs1
   reg0D_in <= X"0000" & X"00" & sliders_s & buttons_s;
   
   
   
   

   -- HDL Embedded Text Block 20 interrupt_logic5
   ---this interrupt flag must be cleared by SW (interrupt handler)
   process(clk)
   begin
      if rising_edge(clk) then
          if reset = '1' or irq0_clear='1'  then
             irq0_flag<= '0';
          elsif  irq0_trig = '1' then
             irq0_flag <= '1';
          end if;
      end if;
   end process;   
   
   process(clk)
   begin
      if rising_edge(clk) then
          if reset = '1' or irq1_clear='1'  then
             irq1_flag<= '0';
          elsif  irq1_trig = '1' then
             irq1_flag <= '1';
          end if;
      end if;
   end process;   
   
   ---apply the interrupt mask-----
   irq_o(0) <= irq0_flag and irq0_mask;                  
   irq_o(1) <= irq1_flag and irq1_mask;                  
   


   -- Instance port mappings.
   U_13 : codec_interface
      generic map (
         core_clk_freq_g => 100000000
      )
      port map (
         audio_out_left  => audio_out_left,
         audio_out_right => audio_out_right,
         clk             => clk,
         line_select     => lo,
         mic_select      => lo,
         recdat          => recdat,
         reset           => reset,
         sda_i           => sda_i,
         testmodes       => audio_testmodes,
         audio_in_left   => audio_in_left,
         audio_in_right  => audio_in_right,
         bclk            => bclk,
         mclk            => mclk,
         mute            => mute,
         pbdat           => pbdat,
         pblrc           => pblrc,
         reclrc          => reclrc,
         sample_en_o     => audio_sample_en,
         scl             => scl,
         sda_o           => sda_o,
         sda_t           => sda_t
      );
   U_2 : comp_dds
      generic map (
         nbits_g => 32
      )
      port map (
         fcw        => fcw_lfsr,
         reset      => reset,
         enable     => hi,
         clk        => clk,
         dds_strobe => dds_strobe,
         dds_wave   => dds_wave1
      );
   U_5 : comp_dds
      generic map (
         nbits_g => 32
      )
      port map (
         fcw        => fcw_pulsetrain,
         reset      => reset,
         enable     => hi,
         clk        => clk,
         dds_strobe => pulse_trigger,
         dds_wave   => dds_wave2
      );
   U_3 : comp_delay_bit
      generic map (
         delay_g => 3
      )
      port map (
         din   => serial_rxd,
         reset => reset,
         clk   => clk,
         din_q => serial_rxd_resampled
      );
   U_6 : comp_oneshot
      generic map (
         nbits_g => 32
      )
      port map (
         pulse_length => pulse_length,
         trigger      => pulse_trigger,
         enable       => hi,
         reset        => reset,
         clk          => clk,
         pulse        => pulse
      );
   U_1 : comp_signal_synchr
      generic map (
         simulation_g => simulation_g
      )
      port map (
         buttons      => buttons,
         sliders      => sliders,
         encoder0     => lo2,
         encoder1     => lo2,
         buttons_s    => buttons_s,
         sliders_s    => sliders_s,
         encoder0_s   => open,
         encoder1_s   => open,
         buttons_stb  => buttons_stb,
         sliders_stb  => sliders_stb,
         encoder0_stb => open,
         encoder1_stb => open,
         clk          => clk
      );
   U_0 : lfsr
      generic map (
         seed_g => 1
      )
      port map (
         clk       => clk,
         en        => dds_strobe,
         reset     => reset,
         lfsr_din  => lo,
         lfsr_dout => lfsr_dout
      );
   U_regarray : register_array_resetval
      generic map (
         addr_width_g => 16,             --width of address
         data_width_g => 32,             --width of data
         addr_base_g  => C_SLV_ADDR_BASE,
         addr_range_g => C_SLV_ADDR_RANGE,
         nregs_g      => 16              --number of registers
      )
      port map (
         sbus_o   => sbus_o,
         sbus_i   => sbus_i,
         resetval => resetval,
         reg_din  => reg_din,
         reg_dout => reg_dout,
         we       => reg_we,
         rd       => reg_rd,
         reset    => reset,
         clk      => clk,
         update   => reg_update
      );

end struct;
