-- VHDL Entity axi_mst_sbus_bridge.test_axi_mst.symbol
--
-- Created:
--          by - net.Personal AEE (KPERSM7467)
--          at - 13:45:04 12/15/15
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;

ENTITY test_axi_mst IS
   GENERIC( 
      C_S00_AXI_ADDR_WIDTH   : integer := 6;
      C_S00_AXI_ARUSER_WIDTH : integer := 1;
      C_S00_AXI_AWUSER_WIDTH : integer := 1;
      C_S00_AXI_BUSER_WIDTH  : integer := 1;
      C_S00_AXI_DATA_WIDTH   : integer := 32;
      -- Users to add parameters here
      
      -- User parameters ends
      -- Do not modify the parameters beyond this line
      
      
      -- Parameters of Axi Slave Bus Interface S00_AXI
      C_S00_AXI_ID_WIDTH     : integer := 1;
      C_S00_AXI_RUSER_WIDTH  : integer := 1;
      C_S00_AXI_WUSER_WIDTH  : integer := 1;
      clk_period_g           : time    := 8ps;
      COMMANDS               : string  := "buscommands.txt"
   );
   PORT( 
      s00_axi_arready  : IN     std_logic;
      s00_axi_awready  : IN     std_logic;
      s00_axi_bid      : IN     std_logic_vector (C_S00_AXI_ID_WIDTH-1 DOWNTO 0);
      s00_axi_bresp    : IN     std_logic_vector (1 DOWNTO 0);
      s00_axi_buser    : IN     std_logic_vector (C_S00_AXI_BUSER_WIDTH-1 DOWNTO 0);
      s00_axi_bvalid   : IN     std_logic;
      s00_axi_rdata    : IN     std_logic_vector (C_S00_AXI_DATA_WIDTH-1 DOWNTO 0);
      s00_axi_rid      : IN     std_logic_vector (C_S00_AXI_ID_WIDTH-1 DOWNTO 0);
      s00_axi_rlast    : IN     std_logic;
      s00_axi_rresp    : IN     std_logic_vector (1 DOWNTO 0);
      s00_axi_ruser    : IN     std_logic_vector (C_S00_AXI_RUSER_WIDTH-1 DOWNTO 0);
      s00_axi_rvalid   : IN     std_logic;
      s00_axi_wready   : IN     std_logic;
      -- User ports ends
      -- Do not modify the ports beyond this line
      
      
      -- Ports of Axi Slave Bus Interface S00_AXI
      s00_axi_aclk     : OUT    std_logic;
      s00_axi_araddr   : OUT    std_logic_vector (C_S00_AXI_ADDR_WIDTH-1 DOWNTO 0);
      s00_axi_arburst  : OUT    std_logic_vector (1 DOWNTO 0);
      s00_axi_arcache  : OUT    std_logic_vector (3 DOWNTO 0);
      s00_axi_aresetn  : OUT    std_logic;
      s00_axi_arid     : OUT    std_logic_vector (C_S00_AXI_ID_WIDTH-1 DOWNTO 0);
      s00_axi_arlen    : OUT    std_logic_vector (7 DOWNTO 0);
      s00_axi_arlock   : OUT    std_logic;
      s00_axi_arprot   : OUT    std_logic_vector (2 DOWNTO 0);
      s00_axi_arqos    : OUT    std_logic_vector (3 DOWNTO 0);
      s00_axi_arregion : OUT    std_logic_vector (3 DOWNTO 0);
      s00_axi_arsize   : OUT    std_logic_vector (2 DOWNTO 0);
      s00_axi_aruser   : OUT    std_logic_vector (C_S00_AXI_ARUSER_WIDTH-1 DOWNTO 0);
      s00_axi_arvalid  : OUT    std_logic;
      s00_axi_awaddr   : OUT    std_logic_vector (C_S00_AXI_ADDR_WIDTH-1 DOWNTO 0);
      s00_axi_awburst  : OUT    std_logic_vector (1 DOWNTO 0);
      s00_axi_awcache  : OUT    std_logic_vector (3 DOWNTO 0);
      s00_axi_awid     : OUT    std_logic_vector (C_S00_AXI_ID_WIDTH-1 DOWNTO 0);
      s00_axi_awlen    : OUT    std_logic_vector (7 DOWNTO 0);
      s00_axi_awlock   : OUT    std_logic;
      s00_axi_awprot   : OUT    std_logic_vector (2 DOWNTO 0);
      s00_axi_awqos    : OUT    std_logic_vector (3 DOWNTO 0);
      s00_axi_awregion : OUT    std_logic_vector (3 DOWNTO 0);
      s00_axi_awsize   : OUT    std_logic_vector (2 DOWNTO 0);
      s00_axi_awuser   : OUT    std_logic_vector (C_S00_AXI_AWUSER_WIDTH-1 DOWNTO 0);
      s00_axi_awvalid  : OUT    std_logic;
      s00_axi_bready   : OUT    std_logic;
      s00_axi_rready   : OUT    std_logic;
      s00_axi_wdata    : OUT    std_logic_vector (C_S00_AXI_DATA_WIDTH-1 DOWNTO 0);
      s00_axi_wlast    : OUT    std_logic;
      s00_axi_wstrb    : OUT    std_logic_vector ((C_S00_AXI_DATA_WIDTH/8)-1 DOWNTO 0);
      s00_axi_wuser    : OUT    std_logic_vector (C_S00_AXI_WUSER_WIDTH-1 DOWNTO 0);
      s00_axi_wvalid   : OUT    std_logic
   );

-- Declarations

END test_axi_mst ;

--
-- VHDL Architecture axi_mst_sbus_bridge.test_axi_mst.fsm
--
-- Created:
--          by - net.Personal AEE (KPERSM7467)
--          at - 13:45:05 12/15/15
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.1 (Build 8)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_arith.all;
library std;
use std.textio.all;
 
ARCHITECTURE fsm OF test_axi_mst IS

   -- Architecture Declarations
   signal clk: std_logic;
   signal reset: std_logic;
   
   
   signal bus_address_int: std_logic_vector(31 downto 0) := (others => '0');
   signal bus_data_int: std_logic_vector(31 downto 0) := (others => '0');
   signal bus_din_int: std_logic_vector(31 downto 0);
   signal bus_data_en: std_logic;
   signal next_cmd: std_logic := '0';
   signal rnw: std_logic;
   signal stop: std_logic := '0';
   signal halt: std_logic := '0';
   signal data_en: std_logic;
   
   
   ------convert string with 8 elements to 32-bit standard logic vector 
   
   function STR8_2VEC (str: string (8 downto 1)) return std_logic_vector is
      variable vec: std_logic_vector(31 downto 0);
      variable tmp: std_logic_vector(3 downto 0);
   begin
       for i in 0 to 7 loop
          case str(i+1) is
             when '0'=> tmp := "0000";
             when '1'=> tmp := "0001";
             when '2'=> tmp := "0010";
             when '3'=> tmp := "0011";
             when '4'=> tmp := "0100";
             when '5'=> tmp := "0101";
             when '6'=> tmp := "0110";
             when '7'=> tmp := "0111";
             when '8'=> tmp := "1000";
             when '9'=> tmp := "1001";
             when 'A'=> tmp := "1010";
             when 'B'=> tmp := "1011";
             when 'C'=> tmp := "1100";
             when 'D'=> tmp := "1101";
             when 'E'=> tmp := "1110";
             when 'F'=> tmp := "1111";
             when others =>  tmp := "XXXX";
           end case;
           vec(4*i+3 downto 4*i) := tmp;
       end loop;
       return(vec);
   end STR8_2VEC;

   TYPE STATE_TYPE IS (
      s_reset,
      s_fetch,
      s_busarb,
      s_exec,
      s_wr0,
      s_read,
      s_wr1,
      s_wr2,
      s_wr3
   );
 
   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk
   )
   -----------------------------------------------------------------
   BEGIN
      IF (clk'EVENT AND clk = '1') THEN
         IF (reset = '1') THEN
            current_state <= s_reset;
         ELSE
            current_state <= next_state;

            -- Combined Actions
            CASE current_state IS
               WHEN s_reset => 
                  data_en <= '0';
               WHEN s_fetch => 
                  data_en <= '0';
                  IF (halt = '0' and stop = '0') THEN 
                     next_cmd <= not next_cmd;
                  END IF;
               WHEN s_busarb => 
                  data_en <= '0';
               WHEN s_wr2 => 
                  bus_din_int <= s00_axi_rdata;
               WHEN OTHERS =>
                  NULL;
            END CASE;
         END IF;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      current_state,
      halt,
      rnw,
      s00_axi_arready,
      s00_axi_awready,
      s00_axi_rlast,
      s00_axi_rvalid,
      s00_axi_wready,
      stop
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN s_reset => 
            next_state <= s_fetch;
         WHEN s_fetch => 
            IF (halt = '0' and stop = '0') THEN 
               next_state <= s_busarb;
            ELSE
               next_state <= s_fetch;
            END IF;
         WHEN s_busarb => 
            IF (stop = '1' or halt = '1') THEN 
               next_state <= s_fetch;
            ELSE
               next_state <= s_exec;
            END IF;
         WHEN s_exec => 
            IF (rnw = '0') THEN 
               next_state <= s_wr0;
            ELSE
               next_state <= s_read;
            END IF;
         WHEN s_wr0 => 
            IF (s00_axi_awready = '1') THEN 
               next_state <= s_wr1;
            ELSE
               next_state <= s_wr0;
            END IF;
         WHEN s_read => 
            IF (s00_axi_arready = '1') THEN 
               next_state <= s_wr2;
            ELSE
               next_state <= s_read;
            END IF;
         WHEN s_wr1 => 
            IF (s00_axi_wready = '1') THEN 
               next_state <= s_fetch;
            ELSE
               next_state <= s_wr1;
            END IF;
         WHEN s_wr2 => 
            IF (s00_axi_rvalid = '1' and s00_axi_rlast = '1') THEN 
               next_state <= s_wr3;
            ELSE
               next_state <= s_wr2;
            END IF;
         WHEN s_wr3 => 
            next_state <= s_fetch;
         WHEN OTHERS =>
            next_state <= s_reset;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : PROCESS ( 
      bus_address_int,
      bus_data_int,
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default Assignment
      s00_axi_arburst <= (others => '0');
      s00_axi_arcache <= (others => '0');
      s00_axi_arid <= (others => '0');
      s00_axi_arlen <= (others => '0');
      s00_axi_arlock <= '0';
      s00_axi_arprot <= (others => '0');
      s00_axi_arqos <= (others => '0');
      s00_axi_arregion <= (others => '0');
      s00_axi_arsize <= (others => '0');
      s00_axi_aruser <= (others => '0');
      s00_axi_arvalid <= '0';
      s00_axi_awburst <= (others => '0');
      s00_axi_awcache <= (others => '0');
      s00_axi_awid <= (others => '0');
      s00_axi_awlen <= (others => '0');
      s00_axi_awlock <= '0';
      s00_axi_awprot <= (others => '0');
      s00_axi_awqos <= (others => '0');
      s00_axi_awregion <= (others => '0');
      s00_axi_awsize <= (others => '0');
      s00_axi_awuser <= (others => '0');
      s00_axi_awvalid <= '0';
      s00_axi_wlast <= '0';
      s00_axi_wstrb <= (others => '0');
      s00_axi_wuser <= (others => '0');
      s00_axi_wvalid <= '0';

      -- Combined Actions
      CASE current_state IS
         WHEN s_wr0 => 
            s00_axi_awvalid <= '1';
            s00_axi_awaddr <= bus_address_int(s00_axi_awaddr'range);
            s00_axi_wdata <= bus_data_int;
         WHEN s_read => 
            s00_axi_arvalid <= '1';
            s00_axi_araddr <= bus_address_int(s00_axi_araddr'range );
         WHEN s_wr1 => 
            s00_axi_wvalid <= '1';
            s00_axi_wlast <= '1';
            s00_axi_wstrb <= (others => '1');
            s00_axi_awaddr <= bus_address_int(s00_axi_awaddr'range);
            s00_axi_wdata <= bus_data_int;
         WHEN s_wr2 => 
            s00_axi_araddr <= bus_address_int(s00_axi_araddr'range);
         WHEN s_wr3 => 
            s00_axi_rready <= '1';
         WHEN OTHERS =>
            NULL;
      END CASE;
   END PROCESS output_proc;
 
   -- Concurrent Statements
   process
   begin
      clk <= '0';
      wait for clk_period_g/2;
      clk <= '1';
      wait for clk_period_g/2;
   end process;
   
   process
   begin
      reset <= '1';
      wait for 10*clk_period_g;
      reset <= '0';
      wait;
   end process;
   
   s00_axi_aclk <= clk;
   s00_axi_aresetn <= not reset;
   
   
   -- synthesis translate_off
   ------------------------------------------------------------------------------
   ---Read Command File
   ------------------------------------------------------------------------------
   
       readcmd:process
       file textfile:   text is in COMMANDS;
       variable l: line;
       variable cmd:  string(1 to 4);
       variable address: string(1 to 8);
       variable data: string(1 to 8);
       variable num: integer;
       variable separator: character;
       variable timestamp_v, waittime_v: time;
       variable byte_addr: std_logic_vector(31 downto 0);
       begin
          while not endfile(textfile) loop
             wait until next_cmd'event;  
            readline(textfile, l);
            read(l, cmd);
            case cmd is
               when "MEMW" =>    read(l,separator);
                                 read(l,address);
                                 read(l,separator);
                                 read(l,data);
                                 byte_addr := STR8_2VEC(address);
                              bus_address_int <=  byte_addr(29 downto 0) & "00";
                                bus_data_int <= STR8_2VEC(data); 
                                 rnw <= '0';
                 when "MEMR" =>  read(l,separator);
                                 read(l,address);
                                 byte_addr := STR8_2VEC(address);
                                 bus_address_int <=  byte_addr(29 downto 0) & "00";
                                 rnw <= '1';
                 when "TIME" =>  read(l,separator);
                                 read(l,timestamp_v);
                                waittime_v := timestamp_v - now;
                                halt <= '1';
                                wait for waittime_v;  
                                halt <= '0';
    
   
                when others =>   assert false report "Unrecognised Instruction"
                                 severity failure;
            end case;                    
         
         end loop;
         stop <= '1';
         assert false report "Simulation complete" severity note;
   
         wait;
   
       end process readcmd;
   
   
   --eof <= not stop;
   
   -- synthesis translate_on
END fsm;
