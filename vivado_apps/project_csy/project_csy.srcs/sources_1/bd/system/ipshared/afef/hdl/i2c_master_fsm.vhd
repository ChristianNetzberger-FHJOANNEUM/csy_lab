-- VHDL Entity csy_lib.i2c_master.symbol
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 19:03:18 23.10.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
library ieee;
use ieee.std_logic_1164.ALL;
use ieee.std_logic_arith.ALL;
use ieee.std_logic_unsigned.all;
--library work;
--use work.busdef.ALL;

entity i2c_master is
   generic( 
      i2c_slv_addr_g   : std_logic_vector := "0011010";
      i2c_baudrate_g   : integer          := 100000;
      core_clk_frequ_g : integer          := 100000000
   );
   port( 
      clk       : in     std_logic;
      i2c_sda_i : in     std_logic;
      reg_addr  : in     std_logic_vector (6 downto 0);
      reg_wdata : in     std_logic_vector (8 downto 0);
      reg_we    : in     std_logic;
      reset     : in     std_logic;
      i2c_scl   : out    std_logic;
      i2c_sda_o : out    std_logic;
      reg_rd    : in     std_logic;
      reg_ack   : out    std_logic;
      reg_rdata : out    std_logic_vector (8 downto 0);
      state     : out    std_logic_vector (3 downto 0)
   );

-- Declarations

end i2c_master ;

--
-- VHDL Architecture csy_lib.i2c_master.fsm
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 13:31:46 07.04.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
library ieee;
use ieee.std_logic_1164.ALL;
use ieee.std_logic_arith.ALL;
--library work;
--use work.busdef.ALL;
use ieee.std_logic_unsigned.all;
 
architecture fsm of i2c_master is

   -- Architecture Declarations
     signal tick_gen_cnt: std_logic_vector(15 downto 0);
     signal tick: std_logic;
     constant tick_period_c: integer := core_clk_frequ_g / i2c_baudrate_g / 4; 
     signal tick_cnt: std_logic_vector(7 downto 0);
     signal tick_cnt_en: std_logic;
     signal bit_cnt: std_logic_vector(5 downto 0);
     signal bit_phase: std_logic_vector(1 downto 0);
     signal i2c_write_message: std_logic_vector(48 downto 0);
     signal sreg,i2c_read_message: std_logic_vector(48 downto 0);
     signal rxreg: std_logic_vector(31 downto 0);
    signal rxdata: std_logic_vector(8 downto 0);
     signal scl: std_logic;
     signal reg_we_q, reg_rd_q: std_logic;
     signal reg_ack_tmp: std_logic;
     signal sda: std_logic;
   
     attribute mark_debug : string;
   --#pragma translate_on
   attribute mark_debug of tick: signal is "true";
   attribute mark_debug of bit_phase :  signal is "true";
   attribute mark_debug of bit_cnt :  signal is "true";
   attribute mark_debug of scl :  signal is "true";
   attribute mark_debug of sreg :  signal is "true";
   attribute mark_debug of sda :  signal is "true";
   
   
   --#pragma translate_on
   
    

   type state_type is (
      s_idle,
      s_start0,
      s_reset,
      s_start1,
      s_bit0,
      s_bit1,
      s_bit2,
      s_bit3,
      s_start2,
      s_stop1,
      s_stop2,
      s_stop3,
      s_start3,
      s_start4,
      s_stop4,
      s_start5,
      s_stop5,
      s_bit4,
      s_stop6,
      s_bit5,
      s_bit6,
      s_bit7
   );
 
   -- Declare current and next state signals
   signal current_state : state_type;
   signal next_state : state_type;

begin

   -----------------------------------------------------------------
   clocked_proc : process ( 
      clk
   )
   -----------------------------------------------------------------
   begin
      if (clk'event and clk = '1') then
         if (reset = '1') then
            current_state <= s_idle;
            -- Default Reset Values
            sreg <= (others => '1');
            rxdata <= (others => '0');
         else
            current_state <= next_state;

            -- Combined Actions
            case current_state is
               when s_idle => 
                  bit_cnt <= (others => '0');
                  if (reg_we = '1') then 
                     sreg <= i2c_write_message;
                  elsif (reg_rd = '1') then 
                     sreg <= i2c_read_message;
                  end if;
               when s_reset => 
                  sreg <= (others => '1');
               when s_start1 => 
                  if (tick = '1') then 
                     sreg <= sreg(sreg'left-1 downto 0) & '1';
                  end if;
               when s_bit2 => 
                  if (tick = '1') then 
                     sreg <= sreg(sreg'left-1 downto 0) & '1';
                  end if;
               when s_bit3 => 
                  if (tick = '1' and bit_cnt = 26) then 
                  elsif (tick = '1') then 
                     bit_cnt <= bit_cnt+1;
                  end if;
               when s_stop1 => 
                  if (tick = '1') then 
                     sreg <= sreg(sreg'left-1 downto 0) & '1';
                  end if;
               when s_start4 => 
                  if (tick = '1') then 
                     sreg <= sreg(sreg'left-1 downto 0) & '1';
                  end if;
               when s_stop4 => 
                  if (tick = '1') then 
                     sreg <= sreg(sreg'left-1 downto 0) & '1';
                  end if;
               when s_stop6 => 
                  rxdata <= rxreg(1) & rxreg(17 downto 10);
               when s_bit5 => 
                  if (tick = '1') then 
                     rxreg <= rxreg(rxreg'left-1 downto 0) & i2c_sda_i;
                  end if;
               when s_bit6 => 
                  if (tick = '1') then 
                     sreg <= sreg(sreg'left-1 downto 0) & '1';
                  end if;
               when s_bit7 => 
                  if (tick = '1' and bit_cnt = 46) then 
                  elsif (tick = '1') then 
                     bit_cnt <= bit_cnt+1;
                  end if;
               when others =>
                  null;
            end case;
         end if;
      end if;
   end process clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : process ( 
      bit_cnt,
      current_state,
      reg_rd,
      reg_we,
      tick
   )
   -----------------------------------------------------------------
   begin
      case current_state is
         when s_idle => 
            if (reg_we = '1') then 
               next_state <= s_start0;
            elsif (reg_rd = '1') then 
               next_state <= s_start3;
            else
               next_state <= s_idle;
            end if;
         when s_start0 => 
            if (tick = '1') then 
               next_state <= s_start1;
            else
               next_state <= s_start0;
            end if;
         when s_reset => 
            next_state <= s_idle;
         when s_start1 => 
            if (tick = '1') then 
               next_state <= s_start2;
            else
               next_state <= s_start1;
            end if;
         when s_bit0 => 
            if (tick = '1') then 
               next_state <= s_bit1;
            else
               next_state <= s_bit0;
            end if;
         when s_bit1 => 
            if (tick = '1') then 
               next_state <= s_bit2;
            else
               next_state <= s_bit1;
            end if;
         when s_bit2 => 
            if (tick = '1') then 
               next_state <= s_bit3;
            else
               next_state <= s_bit2;
            end if;
         when s_bit3 => 
            if (tick = '1' and bit_cnt = 26) then 
               next_state <= s_stop1;
            elsif (tick = '1') then 
               next_state <= s_bit0;
            else
               next_state <= s_bit3;
            end if;
         when s_start2 => 
            if (tick = '1') then 
               next_state <= s_bit0;
            else
               next_state <= s_start2;
            end if;
         when s_stop1 => 
            if (tick = '1') then 
               next_state <= s_stop2;
            else
               next_state <= s_stop1;
            end if;
         when s_stop2 => 
            if (tick = '1') then 
               next_state <= s_stop3;
            else
               next_state <= s_stop2;
            end if;
         when s_stop3 => 
            if (tick = '1') then 
               next_state <= s_idle;
            else
               next_state <= s_stop3;
            end if;
         when s_start3 => 
            if (tick = '1') then 
               next_state <= s_start4;
            else
               next_state <= s_start3;
            end if;
         when s_start4 => 
            if (tick = '1') then 
               next_state <= s_start5;
            else
               next_state <= s_start4;
            end if;
         when s_stop4 => 
            if (tick = '1') then 
               next_state <= s_stop5;
            else
               next_state <= s_stop4;
            end if;
         when s_start5 => 
            if (tick = '1') then 
               next_state <= s_bit4;
            else
               next_state <= s_start5;
            end if;
         when s_stop5 => 
            if (tick = '1') then 
               next_state <= s_stop6;
            else
               next_state <= s_stop5;
            end if;
         when s_bit4 => 
            if (tick = '1') then 
               next_state <= s_bit5;
            else
               next_state <= s_bit4;
            end if;
         when s_stop6 => 
            if (tick = '1') then 
               next_state <= s_idle;
            else
               next_state <= s_stop6;
            end if;
         when s_bit5 => 
            if (tick = '1') then 
               next_state <= s_bit6;
            else
               next_state <= s_bit5;
            end if;
         when s_bit6 => 
            if (tick = '1') then 
               next_state <= s_bit7;
            else
               next_state <= s_bit6;
            end if;
         when s_bit7 => 
            if (tick = '1' and bit_cnt = 46) then 
               next_state <= s_stop4;
            elsif (tick = '1') then 
               next_state <= s_bit4;
            else
               next_state <= s_bit7;
            end if;
         when others =>
            next_state <= s_idle;
      end case;
   end process nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : process ( 
      bit_cnt,
      current_state,
      tick
   )
   -----------------------------------------------------------------
   begin
      -- Default Assignment
      reg_ack <= '0';
      -- Default Assignment To Internals
      tick_cnt_en <= '1';
      scl <= '1';

      -- Combined Actions
      case current_state is
         when s_idle => 
            tick_cnt_en <= '0';
            state <= X"2";
         when s_start0 => 
            state <= X"3";
         when s_reset => 
            tick_cnt_en <= '0';
            state <= X"1";
         when s_start1 => 
            scl <= '0';
            state <= X"4";
         when s_bit0 => 
            scl <= '1';
            state <= X"6";
         when s_bit1 => 
            scl <= '1';
            state <= X"7";
         when s_bit2 => 
            scl <= '0';
            state <= X"8";
         when s_bit3 => 
            scl <= '0';
            state <= X"9";
         when s_start2 => 
            scl <= '0';
            state <= X"5";
         when s_stop1 => 
            scl <= '1';
            state <= X"A";
         when s_stop2 => 
            scl <= '1';
            state <= X"B";
         when s_stop3 => 
            scl <= '1';
            
            state <= X"C";
            if (tick = '1') then 
               reg_ack <= '1';
            end if;
         when s_start3 => 
            state <= X"3";
         when s_start4 => 
            scl <= '0';
            state <= X"4";
         when s_stop4 => 
            scl <= '1';
            state <= X"A";
         when s_start5 => 
            scl <= '0';
            state <= X"5";
         when s_stop5 => 
            scl <= '1';
            state <= X"B";
         when s_bit4 => 
            scl <= '1';
            state <= X"6";
         when s_stop6 => 
            scl <= '1';
            
            state <= X"C";
            if (tick = '1') then 
               reg_ack <= '1';
            end if;
         when s_bit5 => 
            scl <= '1';
            state <= X"7";
         when s_bit6 => 
            if bit_cnt  /= 18 and bit_cnt < 46  then
            scl <= '0';
            end if; 
            state <= X"8";
         when s_bit7 => 
            if bit_cnt  /= 18 and bit_cnt < 46 then
            scl <= '0';
            end if; 
            
            state <= X"9";
         when others =>
            null;
      end case;
   end process output_proc;
 
   -- Concurrent Statements
   ----tick generation counter: create tick at 4x baudrate
     process(clk)
     begin
       if rising_edge(clk) then
         if reset = '1' then
            tick_gen_cnt <= (others => '0');
         elsif tick = '1' then
            tick_gen_cnt <= (others => '0');
         else
            tick_gen_cnt <= tick_gen_cnt+1;
         end if;
       end if;
     end process;
     tick <= '1' when tick_gen_cnt = tick_period_c-1 else '0';
     
     -----tick counter-------
     process(clk)
     begin
       if rising_edge(clk) then
         if reset = '1' or tick_cnt_en = '0' then
            tick_cnt <= (others => '0');
         elsif tick = '1' then
            tick_cnt <= tick_cnt+1;
         end if;
       end if;
     end process;
      
      -- bit timing within i2c_message--------
      --bit_cnt   <= tick_cnt(7 downto 2);
      bit_phase <= tick_cnt(1 downto 0);
   
       -------i2c write message ---- 3x 9 bit + startconditoin + stopcondition
       --    startcondition & i2c_slv_addr % r/w $ ack & reg_addr(6:0) & reg_wdata(8) & ack & reg_wdata(7:0) & ack & stopcondition
       i2c_write_message <= '0' & i2c_slv_addr_g & '0' & '1' & reg_addr & reg_wdata(8) & '1' & reg_wdata(7 downto 0) & '1' & '0' & "11111111111111111111";
       i2c_read_message <= '0' & i2c_slv_addr_g & '0' & '1' & reg_addr & '0' & '1' & '1' &  '0' & i2c_slv_addr_g & '1' & '1' & "11111111" & '0' & "11111111" & '1' & '0';
       sda <= sreg(sreg'left); 
       i2c_sda_o <= sreg(sreg'left); 
        i2c_scl <= scl;
   
   reg_rdata <= rxdata;
end fsm;
