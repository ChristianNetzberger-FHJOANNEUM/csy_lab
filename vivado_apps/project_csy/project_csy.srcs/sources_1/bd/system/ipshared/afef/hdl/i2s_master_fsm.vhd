-- VHDL Entity csy_lib.i2s_master.symbol
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 20:56:22 06.11.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
library ieee;
use ieee.std_logic_1164.ALL;
use ieee.std_logic_arith.ALL;
--library work;
--use work.busdef.ALL;

entity i2s_master is
   port( 
      audio_out_left  : in     std_logic_vector (23 downto 0);
      audio_out_right : in     std_logic_vector (23 downto 0);
      clk             : in     std_logic;
      recdat          : in     std_logic;
      reset           : in     std_logic;
      audio_in_left   : out    std_logic_vector (23 downto 0);
      audio_in_right  : out    std_logic_vector (23 downto 0);
      bclk            : out    std_logic;
      debug           : out    std_logic_vector (7 downto 0);
      mclk            : out    std_logic;
      pbdat           : out    std_logic;
      pblrc           : out    std_logic;
      reclrc          : out    std_logic;
      sample_in       : out    std_logic
   );

-- Declarations

end i2s_master ;

--
-- VHDL Architecture csy_lib.i2s_master.fsm
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 13:32:09 07.04.2018
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
library ieee;
use ieee.std_logic_1164.ALL;
use ieee.std_logic_arith.ALL;
use ieee.std_logic_unsigned.all;
 
architecture fsm of i2s_master is

   -- Architecture Declarations
   signal mclk_cnt: std_logic_vector(10 downto 0);
   signal bclk_stb, reclrc_stb: std_logic;
   signal bclk_int, reclrc_int, pbdat_int: std_logic;
   signal txreg,sreg, rx_right, rx_left: std_logic_vector(23 downto 0);
   signal cnt: std_logic_vector(7 downto 0);

   type state_type is (
      s_reset,
      s_left0,
      s_idle,
      s_right
   );
 
   -- Declare current and next state signals
   signal current_state : state_type;
   signal next_state : state_type;

   -- Declare any pre-registered internal signals
   signal sample_in_cld : std_logic ;

begin

   -----------------------------------------------------------------
   clocked_proc : process ( 
      clk
   )
   -----------------------------------------------------------------
   begin
      if (clk'event and clk = '1') then
         if (reset = '1') then
            current_state <= s_reset;
         else
            current_state <= next_state;
            -- Default Assignment To Internals
            sample_in_cld <= '0';

            -- Combined Actions
            case current_state is
               when s_left0 => 
                  if (bclk_stb='1' and cnt = 24) then 
                     rx_left <= sreg;
                     sample_in_cld <= '1';
                  elsif (bclk_stb='1') then 
                     sreg <= sreg(sreg'left-1 downto 0)  & recdat;
                     txreg <= txreg(txreg'left-1 downto 0)  & '0';
                     cnt <= cnt+1;
                  end if;
               when s_idle => 
                  if (reclrc_stb = '1' and reclrc_int = '1') then 
                     cnt <= (others => '0');
                     sreg <= (others => '0');
                     txreg <= audio_out_left;
                  elsif (reclrc_stb = '1') then 
                     cnt <= (others => '0');
                     sreg <= (others => '0');
                     txreg <= audio_out_right;
                  end if;
               when s_right => 
                  if (bclk_stb='1' and cnt = 24) then 
                     rx_right <= sreg;
                  elsif (bclk_stb='1') then 
                     sreg <= sreg(sreg'left-1 downto 0)  & recdat;
                     txreg <= txreg(txreg'left-1 downto 0)  & '0';
                     cnt <= cnt+1;
                  end if;
               when others =>
                  null;
            end case;
         end if;
      end if;
   end process clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : process ( 
      bclk_stb,
      cnt,
      current_state,
      reclrc_int,
      reclrc_stb
   )
   -----------------------------------------------------------------
   begin
      case current_state is
         when s_reset => 
            next_state <= s_idle;
         when s_left0 => 
            if (bclk_stb='1' and cnt = 24) then 
               next_state <= s_idle;
            elsif (bclk_stb='1') then 
               next_state <= s_left0;
            else
               next_state <= s_left0;
            end if;
         when s_idle => 
            if (reclrc_stb = '1' and reclrc_int = '1') then 
               next_state <= s_left0;
            elsif (reclrc_stb = '1') then 
               next_state <= s_right;
            else
               next_state <= s_idle;
            end if;
         when s_right => 
            if (bclk_stb='1' and cnt = 24) then 
               next_state <= s_idle;
            elsif (bclk_stb='1') then 
               next_state <= s_right;
            else
               next_state <= s_right;
            end if;
         when others =>
            next_state <= s_reset;
      end case;
   end process nextstate_proc;
 
   -- Concurrent Statements
   -- Clocked output assignments
   sample_in <= sample_in_cld;
   process(clk)
   begin
      if rising_edge(clk) then
          if reset = '1' then
              mclk_cnt <= (others => '0');
         else
              mclk_cnt <= mclk_cnt+1;
         end if;
      end if;
   end process;
   
   --12.5 MHz mclk------------
   mclk   <= mclk_cnt(2);
   reclrc_int <= mclk_cnt(10);
   pblrc  <= mclk_cnt(10);
   bclk_int   <= mclk_cnt(4);
   pbdat_int <= txreg(txreg'left); --recdat;
   
   reclrc <= reclrc_int;
   bclk   <= bclk_int;
   pbdat <= pbdat_int;
   
   audio_in_left <= rx_left;
   audio_in_right <= rx_right;
   
   debug(0)   <= mclk_cnt(2);
   debug(1)  <= mclk_cnt(10);
   debug(2)   <= mclk_cnt(4);
   debug(3) <= pbdat_int;
   debug(4) <= reclrc_int;
   debug(7 downto 5) <= "000";
   
   process(clk)
   variable q0,q1: std_logic;
   begin
      if rising_edge(clk) then       
          bclk_stb <= bclk_int and not q0;
          q0 := bclk_int;
          reclrc_stb <= reclrc_int xor q1;
          q1 := reclrc_int;
     end if;
   end process;
end fsm;
