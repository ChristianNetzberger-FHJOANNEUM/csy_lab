-- VHDL Entity csy_lib.i2c_config.symbol
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 20:56:09 06.11.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
library ieee;
use ieee.std_logic_1164.ALL;
use ieee.std_logic_arith.ALL;
--library work;
--use work.busdef.ALL;
use ieee.std_logic_unsigned.all;

entity i2c_config is
   port( 
      clk          : in     std_logic;
      reg_ack      : in     std_logic;
      reg_addr_in  : in     std_logic_vector (6 downto 0);
      reg_rdata    : in     std_logic_vector (8 downto 0);
      reg_wdata_in : in     std_logic_vector (8 downto 0);
      reg_we_in    : in     std_logic;
      reset        : in     std_logic;
      trig         : in     std_logic;
      cstate       : out    std_logic_vector (3 downto 0);
      reg_addr     : out    std_logic_vector (6 downto 0);
      reg_rd       : out    std_logic;
      reg_wdata    : out    std_logic_vector (8 downto 0);
      reg_we       : out    std_logic
   );

-- Declarations

end i2c_config ;

--
-- VHDL Architecture csy_lib.i2c_config.fsm
--
-- Created:
--          by - net.UNKNOWN (KPERSM7467)
--          at - 16:59:42 09.11.2017
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2016.2 (Build 5)
--
library ieee;
use ieee.std_logic_1164.ALL;
use ieee.std_logic_arith.ALL;
--library work;
--use work.busdef.ALL;
use ieee.std_logic_unsigned.all;
 
architecture fsm of i2c_config is

   -- Architecture Declarations
   signal timer: std_logic_vector(23 downto 0);
   signal addr: std_logic_vector(reg_addr'range);
   signal we: std_logic;
   signal rd: std_logic;
   signal wdata: std_logic_vector(reg_wdata'range);
   signal cnt: std_logic_vector(3 downto 0);
   signal debug: std_logic;
   
   type reg_array_t is array (0 to 11) of std_logic_vector(8 downto 0);
   signal reg_array: reg_array_t := (others => (others => '0'));
   signal write_reg_array: reg_array_t := 
                      ("000010111",  -- 0
                       "000010111",  -- 1
                       "001111001",  -- 2
                       "001111001",  -- 3
                       "000010010",  -- 4
                       "000000000",  -- 5
                       "000010000",  -- 6
                       "000001001",  -- 7
                       "000000000", -- 8
                       "000000000", -- 9
      others =>  "000000000");
    

   type state_type is (
      s_reset,
      s_init,
      s_delay,
      s_activebit,
      s_outbit,
      s_end,
      s_wait,
      s_read_reg,
      s_swreset,
      s_init0,
      s_read_reg2,
      s_regwr,
      s_regwr1
   );
 
   -- Declare current and next state signals
   signal current_state : state_type;
   signal next_state : state_type;

    attribute mark_debug : string;
   --#pragma translate_on
    attribute mark_debug of reg_array :  signal is "true";

begin

   -----------------------------------------------------------------
   clocked_proc : process ( 
      clk
   )
   -----------------------------------------------------------------
   begin
      if (clk'event and clk = '1') then
         if (reset = '1') then
            current_state <= s_reset;
            -- Default Reset Values
            addr <= (others => '0');
            cnt <= (others => '0');
            rd <= '0';
            timer <= (others => '0');
            wdata <= (others => '0');
            we <= '0';
         else
            current_state <= next_state;
            -- Default Assignment To Internals
            rd <= '0';
            we <= '0';

            -- Interrupts
            if (trig = '1') then
               null;
            elsif (reg_we_in = '1') then
               null;
            else

               -- Combined Actions
               case current_state is
                  when s_reset => 
                     timer <= (others => '0');
                     cnt <= (others => '0');
                  when s_init => 
                     if (reg_ack = '1' and cnt = 10) then 
                        cnt <= (others => '0');
                     elsif (reg_ack = '1') then 
                        cnt <= cnt+1;
                     end if;
                  when s_delay => 
                     timer <= timer+1;
                     if (timer = 4000000) then 
                        --set active bit D0 in Register R9
                        wdata <= "000000001";
                        addr <= conv_std_logic_vector(9,addr'length);
                        we <= '1';
                     end if;
                  when s_activebit => 
                     if (reg_ack = '1') then 
                        ---set power management bits in Reg 6 -----
                        wdata <= "000000000";
                        addr <= conv_std_logic_vector(6,addr'length);
                        we <= '1';
                        timer <= (others => '0');
                     end if;
                  when s_outbit => 
                     if (reg_ack = '1') then 
                        ---read registers-----
                        wdata <= "000001001";
                        addr <= "000" & cnt;
                        rd <= '1';
                        timer <= (others => '0');
                     end if;
                  when s_wait => 
                     timer <= timer+1;
                     if (timer = 125000) then 
                        ---software reset-----
                        wdata <= "000000000";
                        addr <= conv_std_logic_vector(15,addr'length);
                        we <= '1';
                        timer <= (others => '0');
                     end if;
                  when s_read_reg => 
                     if (reg_ack = '1' and cnt = 12) then 
                     elsif (reg_ack = '1') then 
                        cnt <= cnt+1;
                        reg_array(conv_integer(cnt)) <= reg_rdata;
                     end if;
                  when s_swreset => 
                     if (reg_ack = '1') then 
                        ---set power management bits in Reg 6 except D4-----
                        wdata <= write_reg_array(conv_integer(cnt));
                        addr <= "000"&cnt;
                        we <= '1';
                        timer <= (others => '0');
                     end if;
                  when s_init0 => 
                     ---set power management bits in Reg 6 except D4-----
                     wdata <= write_reg_array(conv_integer(cnt));
                     addr <= "000"&cnt;
                     we <= '1';
                     timer <= (others => '0');
                  when s_read_reg2 => 
                     ---read registers-----
                     wdata <= "000001001";
                     addr <= "000" & cnt;
                     rd <= '1';
                     timer <= (others => '0');
                  when s_regwr => 
                     ---register write-----
                     wdata <= reg_wdata_in;
                     addr <= reg_addr_in;
                     we <= '1';
                  when others =>
                     null;
               end case;
            end if;
         end if;
      end if;
   end process clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : process ( 
      cnt,
      current_state,
      reg_ack,
      reg_we_in,
      timer,
      trig
   )
   -----------------------------------------------------------------
   begin

      -- Interrupts
      if (trig = '1') then
         next_state <= s_reset;
      elsif (reg_we_in = '1') then
         next_state <= s_regwr;
      else
         case current_state is
            when s_reset => 
               next_state <= s_wait;
            when s_init => 
               if (reg_ack = '1' and cnt = 10) then 
                  next_state <= s_delay;
               elsif (reg_ack = '1') then 
                  next_state <= s_init0;
               else
                  next_state <= s_init;
               end if;
            when s_delay => 
               if (timer = 4000000) then 
                  next_state <= s_activebit;
               else
                  next_state <= s_delay;
               end if;
            when s_activebit => 
               if (reg_ack = '1') then 
                  next_state <= s_outbit;
               else
                  next_state <= s_activebit;
               end if;
            when s_outbit => 
               if (reg_ack = '1') then 
                  next_state <= s_read_reg;
               else
                  next_state <= s_outbit;
               end if;
            when s_end => 
               next_state <= s_end;
            when s_wait => 
               if (timer = 125000) then 
                  next_state <= s_swreset;
               else
                  next_state <= s_wait;
               end if;
            when s_read_reg => 
               if (reg_ack = '1' and cnt = 12) then 
                  next_state <= s_end;
               elsif (reg_ack = '1') then 
                  next_state <= s_read_reg2;
               else
                  next_state <= s_read_reg;
               end if;
            when s_swreset => 
               if (reg_ack = '1') then 
                  next_state <= s_init;
               else
                  next_state <= s_swreset;
               end if;
            when s_init0 => 
               next_state <= s_init;
            when s_read_reg2 => 
               next_state <= s_read_reg;
            when s_regwr => 
               next_state <= s_regwr1;
            when s_regwr1 => 
               if (reg_ack = '1') then 
                  next_state <= s_end;
               else
                  next_state <= s_regwr1;
               end if;
            when others =>
               next_state <= s_reset;
         end case;
      end if;
   end process nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : process ( 
      current_state,
      debug,
      reg_ack,
      reg_we_in,
      timer,
      trig
   )
   -----------------------------------------------------------------
   begin

      -- Interrupts
      if (trig = '1') then
         null;
      elsif (reg_we_in = '1') then
         null;
      else

         -- Combined Actions
         case current_state is
            when s_reset => 
               cstate <= X"1";
            when s_delay => 
               cstate <= X"6";
               if (timer = 4000000) then 
                  cstate <= X"7";
               end if;
            when s_activebit => 
               if (reg_ack = '1') then 
                  cstate <= X"8";
               end if;
            when s_outbit => 
               if (reg_ack = '1') then 
                  cstate <= X"A";
               end if;
            when s_end => 
               if debug = '1' then
                  cstate <= X"B";
               else 
                  cstate <= X"C";
               end if;
            when s_wait => 
               cstate <= X"2";
               if (timer = 125000) then 
                  cstate <= X"3";
               end if;
            when s_swreset => 
               if (reg_ack = '1') then 
                  cstate <= X"4";
               end if;
            when s_init0 => 
               cstate <= X"4";
            when s_read_reg2 => 
               cstate <= X"A";
            when s_regwr => 
               cstate <= X"E";
            when others =>
               null;
         end case;
      end if;
   end process output_proc;
 
   -- Concurrent Statements
   reg_we <= we;
   reg_rd <= rd;
   reg_addr <= addr;
   reg_wdata <= wdata;
   
   process(reg_array)
   variable tmp: std_logic;
   begin
     tmp := '0';
     for i in 0 to 9 loop
         if reg_array(i) = 0 then
             tmp := not tmp;
         end if;
     end loop;
     debug <= tmp; 
   end process;
end fsm;
